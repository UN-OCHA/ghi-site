<?php

/**
 * @file
 * Contains hook implementations for the GHI Subpages module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\ghi_subpages\Controller\SubpagesAdminController;
use Drupal\ghi_subpages\Helpers\SubpageHelper;
use Drupal\node\Entity\NodeType;
use Drupal\node\NodeInterface;

/**
 * Implements hook_entity_insert().
 */
function ghi_subpages_entity_insert(EntityInterface $entity) {
  if (!$entity instanceof NodeInterface) {
    return;
  }

  $node = $entity;
  $supported_base_types = SubpageHelper::SUPPORTED_BASE_TYPES;

  if (!in_array($node->getType(), $supported_base_types)) {
    return;
  }

  SubpageHelper::assureSubpagesForBaseNode($node);
}

/**
 * Implements hook_entity_update().
 */
function ghi_subpages_entity_update(EntityInterface $entity) {
  if (!$entity instanceof NodeInterface) {
    return;
  }

  $node = $entity;
  $supported_base_types = SubpageHelper::SUPPORTED_BASE_TYPES;

  if (!in_array($node->getType(), $supported_base_types)) {
    return;
  }

  SubpageHelper::assureSubpagesForBaseNode($node);

  if (!$node->isPublished()) {
    // Load all subpages and make sure that those are unpublished too.
    /** @var \Drupal\node\NodeInterface[] $subpages */
    $subpages = \Drupal::entityTypeManager()->getStorage('node')->loadByProperties([
      'field_entity_reference' => $node->id(),
    ]);

    if (!empty($subpages)) {
      foreach ($subpages as $subpage) {
        if (!$subpage->isPublished()) {
          continue;
        }
        $node_type = \Drupal::entityTypeManager()->getStorage('node_type')->load($subpage->getType());
        $subpage->setUnpublished();
        $subpage->save();

        \Drupal::messenger()->addStatus(t('Subpage @subpage has been unpublished.', [
          '@subpage' => $node_type->get('name'),
        ]));
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function ghi_subpages_entity_delete(EntityInterface $entity) {
  if (!$entity instanceof NodeInterface) {
    return;
  }

  $node = $entity;
  $supported_base_types = SubpageHelper::SUPPORTED_BASE_TYPES;

  if (!in_array($node->getType(), $supported_base_types)) {
    return;
  }

  SubpageHelper::deleteSubpagesForBaseNode($node);
}

/**
 * Implements hook_entity_access().
 *
 * Check access for full page node views of subpages of the base entities.
 * Allow access only if the base entity is allowed to be viewed.
 */
function ghi_subpages_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if (!$entity instanceof NodeInterface) {
    return AccessResult::neutral();
  }
  $node_types = SubpageHelper::SUPPORTED_SUBPAGE_TYPES + [
    'plan_entity',
    'governing_entity',
  ];
  $node = $entity;
  if (!in_array($node->getType(), $node_types)) {
    // No opinion.
    return AccessResult::neutral();
  }

  if ($operation == 'view') {
    $base_entity = NULL;
    if ($node->hasField('field_entity_reference')) {
      /** @var \Drupal\node\NodeInterface $base_entity */
      $base_entity = $node->field_entity_reference->entity;
    }
    elseif ($node->hasField('field_plan')) {
      /** @var \Drupal\node\NodeInterface $base_entity */
      $base_entity = $node->field_plan->entity;
    }
    if (!$base_entity) {
      // No opinion.
      return AccessResult::neutral();
    }
    $access_result = $base_entity->access($operation, $account) !== TRUE ? AccessResult::forbidden() : AccessResult::allowed();
    return $access_result->addCacheableDependency($entity);
  }

  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_local_tasks_alter().
 *
 * This is used to remove the publish local task coming from the
 * publishcontent module, if it's configured to not display them. This is
 * needed because we alter the route requirements and remove a custom
 * access check which would normally govern the display of the task, in order
 * to be able to use the direct publish/unpublish link from other parts of the
 * site.
 */
function ghi_subpages_local_tasks_alter(&$local_tasks) {
  if (!empty($local_tasks['entity.node.publish'])) {
    $config = \Drupal::configFactory()->get('publishcontent.settings');
    if (empty($config->get('ui_localtask'))) {
      unset($local_tasks['entity.node.publish']);
    }
  }
}

/**
 * Implements hook_preprocess_page_title().
 */
function ghi_subpages_preprocess_page_title(&$variables) {
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node && !in_array($node->bundle(), SubpageHelper::SUPPORTED_BASE_TYPES) && $node->hasField('field_entity_reference') && $node->field_entity_reference->entity) {
    $variables['title'] = $node->field_entity_reference->entity->getTitle();
  }
}

/**
 * Implements hook_menu_links_discovered_alter().
 *
 * Hide links for manual creation of subpage nodes from the admin menu.
 */
function ghi_subpages_menu_links_discovered_alter(&$links) {
  $subpages_admin_controller = new SubpagesAdminController();
  foreach (SubpageHelper::SUPPORTED_SUBPAGE_TYPES as $type) {
    $node_type = NodeType::load($type);
    if ($subpages_admin_controller->nodeCreateAccess($node_type)->isForbidden()) {
      unset($links['admin_toolbar_tools.extra_links:node.add.' . $type]);
    }
  }
}

/**
 * Implements hook_preprocess_node_add_list().
 *
 * Filter the list of content types that are available for manual creation, so
 * that subpages can not be created individually.
 */
function ghi_subpages_preprocess_node_add_list(&$variables) {
  $variables['types'] = [];
  if (!empty($variables['content'])) {
    $subpages_admin_controller = new SubpagesAdminController();
    foreach ($variables['content'] as $key => $type) {
      if ($subpages_admin_controller->nodeCreateAccess($type)->isForbidden()) {
        unset($variables['content'][$key]);
      }
    }
  }
}
