<?php

/**
 * @file
 * Contains hook implementations for the GHI Plans module.
 *
 * The migration hooks in this file could also be put into an event handler.
 *
 * @see https://www.drupal.org/docs/upgrading-drupal/customize-migrations-when-upgrading-to-drupal-8-or-later#s-migrate-plus-provides-a-prepare-row-event
 */

use Drupal\Component\Render\FormattableMarkup;
use Drupal\Component\Utility\Unicode;
use Drupal\ghi_plans\Helpers\PlanStructureHelper;
use Drupal\hpc_api\Query\EndpointQuery;
use Drupal\hpc_common\Helpers\ArrayHelper;
use Drupal\hpc_common\Helpers\NodeHelper;
use Drupal\migrate\MigrateSkipRowException;
use Drupal\migrate\Plugin\MigrateSourceInterface;
use Drupal\migrate\Plugin\MigrationInterface;
use Drupal\migrate\Row;
use Drupal\node\NodeInterface;

/**
 * Implements hook_migrate_MIGRATE_ID_prepare_row().
 */
function ghi_plans_migrate_plan_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $raw_data = (object) $row->getSource()['raw'];

  /** @var \Drupal\hpc_api\Query\EndpointPlanQuery $query */
  $query = \Drupal::service('hpc_api.endpoint_query');

  $has_published_version = FALSE;
  $published_version = NULL;

  // Fetching plan data with version=current for plans without a published
  // version, will result in an empty planVersion property, which will result
  // in us not being able to fetch the plan name. So we fetch current version
  // data whenever possible, and if not possible, we fetch the unpublished
  // version data, but set the plan node to unpublished in Drupal.
  $plan_tags = $raw_data->planTags;

  if (!empty($plan_tags)) {
    $published_versions = array_filter($plan_tags, function ($version) {
      return $version['public'] == TRUE;
    });
    if (!empty($published_versions)) {
      // There can be multiple public plan tags, we want the one with the
      // highest number.
      ArrayHelper::sortArray($published_versions, 'name', EndpointQuery::SORT_DESC, SORT_STRING);
    }
    $published_version = !empty($published_versions) ? reset($published_versions) : NULL;
    $has_published_version = $published_version !== NULL;
  }

  $query->setArguments([
    'endpoint' => 'plan/' . $raw_data->id,
    'api_version' => 'v2',
    'auth_method' => EndpointQuery::AUTH_METHOD_API_KEY,
  ]);
  if ($has_published_version) {
    // If we have plan version tags, let's fetch the most current one.
    $query->setEndpointArgument('version', 'current');
  }
  $plan_data = $query->getData();
  if (!$plan_data) {
    throw new MigrateSkipRowException();
  }

  // First see if this plan exists already. If it doesn't, set it to
  // unpublished first.
  $plan_node = NodeHelper::getNodeFromOriginalId($raw_data->id, 'plan');
  if ($plan_node && $has_published_version) {
    $row->setSourceProperty('status', $plan_node->isPublished());
  }
  else {
    $row->setSourceProperty('status', NodeInterface::NOT_PUBLISHED);
  }

  $row->setSourceProperty('version_tag', $published_version ? $published_version['name'] : NULL);
  $row->setSourceProperty('name', !empty($plan_data->planVersion->name) ? $plan_data->planVersion->name : NULL);

  $row->setSourceProperty('start_date', !empty($plan_data->planVersion->startDate) ? $plan_data->planVersion->startDate : NULL);
  $row->setSourceProperty('end_date', !empty($plan_data->planVersion->endDate) ? $plan_data->planVersion->endDate : NULL);
  $row->setSourceProperty('comments', !empty($plan_data->planVersion->comments) ? $plan_data->planVersion->comments : NULL);

  // Query the API for the prototype of this plan.
  $query->setArguments([
    'api_version' => 'v2',
    'endpoint' => 'plan/' . $raw_data->id . '/entity-prototype',
    'auth_method' => EndpointQuery::AUTH_METHOD_API_KEY,
    'sort' => 'orderNumber',
  ]);
  $prototype = $query->getData();
  if ($prototype) {
    $row->setSourceProperty('prototype', serialize($prototype));
  }

  // Query the API for the reporting periods of this plan.
  if (!empty($plan_data->planVersion->lastPublishedReportingPeriodId)) {
    $query->setArguments([
      'api_version' => 'v2',
      'endpoint' => 'plan/' . $plan_data->id . '/reportingPeriod',
      'auth_method' => EndpointQuery::AUTH_METHOD_API_KEY,
      'sort' => 'periodNumber',
    ]);
    $reporting_periods = [];
    foreach ($query->getData() as $object) {
      if ($object->id > $plan_data->planVersion->lastPublishedReportingPeriodId) {
        continue;
      }
      unset($object->plan);
      $reporting_periods[$object->id] = $object;
    }
    $row->setSourceProperty('reporting_periods', serialize($reporting_periods));
  }

  // Parse the categories to retrieve the categories.
  if (!empty($plan_data->categories)) {
    // Plan type.
    $plan_types = array_filter($plan_data->categories, function ($item) {
      return $item->group == 'planType';
    });
    if (!empty($plan_types)) {
      // There should really be only one.
      $plan_type = reset($plan_types);
      $row->setSourceProperty('plan_type_id', $plan_type->id);
    }

    // Plan costing.
    $plan_costing = array_filter($plan_data->categories, function ($item) {
      return $item->group == 'planCosting';
    });
    if (!empty($plan_costing)) {
      // There should really be only one.
      $plan_costing = reset($plan_costing);
      $row->setSourceProperty('plan_costing_id', $plan_costing->id);
    }
  }

  // Country references.
  if (!empty($raw_data->locations)) {
    $countries = array_filter($raw_data->locations, function ($location) {
      return $location['adminLevel'] == 0;
    });
    $row->setSourceProperty('countries', !empty($countries) ? $countries : []);
  }

  // Then get the year.
  if (!empty($plan_data->years)) {
    // There should really be only one.
    $year = reset($plan_data->years);
    $row->setSourceProperty('plan_year', $year->year);
  }

  unset($plan_data);
}

/**
 * Implements hook_migrate_prepare_row().
 */
function ghi_plans_migrate_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  if (!in_array($migration->id(), ['plan_entity', 'governing_entity'])) {
    return;
  }

  $raw_data = (object) $row->getSource()['raw'];
  $plan_node = NodeHelper::getNodeFromOriginalId($raw_data->plan_id, 'plan');
  if (!$plan_node) {
    // No associated plan node found.
    throw new MigrateSkipRowException();
  }

  // See if this plan entity exists already. If it doesn't, set it to
  // unpublished.
  $plan_entity = NodeHelper::getNodeFromOriginalId($raw_data->id, $raw_data->type);
  if ($plan_entity) {
    $row->setSourceProperty('status', $plan_entity->isPublished());
  }
  else {
    $row->setSourceProperty('status', NodeInterface::NOT_PUBLISHED);
  }

  if (empty($raw_data->name) && !empty($raw_data->description)) {
    $row->setSourceProperty('name', Unicode::truncate($raw_data->description, 255, TRUE, TRUE));
  }

  $subpage = NULL;

  // Retrieve the subpage information from the plan structure. This is used
  // to create the path alias for each plan or governing entity.
  $plan_structure = PlanStructureHelper::getRpmPlanStructure($plan_node);
  if (!empty($plan_structure[$raw_data->entity_type . '_entities'][$raw_data->entity_prototype_id]->subpage)) {
    $subpage = $plan_structure[$raw_data->entity_type . '_entities'][$raw_data->entity_prototype_id]->subpage;
  }
  elseif ($raw_data->entity_type == 'plan') {
    // Plan entities can be children of governing entities.
    foreach ($plan_structure['governing_entities'] as $entity) {
      if (empty($entity->entity_prototype_child_ids)) {
        continue;
      }
      if (!in_array($raw_data->entity_prototype_id, $entity->entity_prototype_child_ids)) {
        continue;
      }
      $subpage = $entity->subpage;
      break;
    }
    // Or they can be children of other plan entities.
    foreach ($plan_structure['plan_entities'] as $entity) {
      if (empty($entity->entity_prototype_child_ids)) {
        continue;
      }
      if (!in_array($raw_data->entity_prototype_id, $entity->entity_prototype_child_ids)) {
        continue;
      }
      $subpage = $entity->subpage;
      break;
    }
  }

  if (empty($subpage)) {
    // If we can't find a subpage to put this entity on, don't import it.
    throw new MigrateSkipRowException();
  }
  $row->setSourceProperty('subpage', $subpage);

}

/**
 * Implements hook_preprocess_node__NODE_TYPE__VIEW_MODE().
 */
function ghi_plans_preprocess_node__plan__full(&$variables) {
  $top_nav = ghi_plans_get_top_navigation($variables['elements']['#node']);
  if (!empty($top_nav)) {
    $variables['content'] += $top_nav;
  }
}

/**
 * Implements hook_preprocess_node__NODE_TYPE__VIEW_MODE().
 */
function ghi_plans_preprocess_node__plan_entity__full(&$variables) {
  $top_nav = ghi_plans_get_top_navigation($variables['elements']['#node']);
  if (!empty($top_nav)) {
    $variables['content'] += $top_nav;
  }
}

/**
 * Get plan top navigation.
 *
 * @param \Drupal\node\NodeInterface $plan
 *   Plan.
 */
function ghi_plans_get_top_navigation(NodeInterface $plan) {
  $output = [];
  if ($plan->getType() !== 'plan' && $plan->getType() !== 'plan_entity') {
    return;
  }

  // Get parent if needed.
  $render_all_children = FALSE;
  if ($plan->getType() === 'plan_entity') {
    $plan = $plan->field_plan->entity;
    $render_all_children = TRUE;
  }

  // Always output parent link.
  $overview_link = t('Overview');
  if (!$plan->isPublished()) {
    if ($plan->access('view')) {
      $overview_link = $plan->toLink($overview_link);
    }
  }
  else {
    $overview_link = $plan->toLink($overview_link);
  }

  $tabs = [
    [
      'title' => t('Overview'),
      'url' => $plan->toUrl(),
      'attributes' => [
        'class' => ['active'],
      ],
    ],
  ];

  // Get all plan entities.
  $plan_entities = $plan->field_plan_entities->referencedEntities();
  $hide_count = $plan->field_plan_hide_gve_counts->value ?? FALSE;

  $cache_tags = [];
  if ($plan_entities) {
    $suffix = '';
    if (!$hide_count) {
      $suffix = ' <span class="counter">' . count($plan_entities) . '</span>';
    }

    /** @var \Drupal\node\NodeInterface $plan_entity */
    $plan_entity = reset($plan_entities);
    $cache_tags = array_merge($cache_tags, $plan_entity->getCacheTags());
    $tabs[] = [
      'title' => new FormattableMarkup(t('Clusters') . $suffix, []),
      'url' => $plan_entity->toUrl(),
      'attributes' => [
        'class' => [],
      ],
    ];
  }

  $output['links_plan_overview'] = [
    '#theme' => 'links',
    '#links' => $tabs,
    '#attributes' => [
      'class' => [
        'links--plan-overview',
      ],
    ],
    '#cache' => [
      'tags' => $cache_tags,
    ],
  ];

  if ($render_all_children) {
    /** @var \Drupal\hpc_api\Query\EndpointPlanQuery $q */
    $q = \Drupal::service('hpc_api.endpoint_plan_query');
    $children = [];

    /** @var \Drupal\node\NodeInterface $plan_entity */
    foreach ($plan_entities as $plan_entity) {
      $cache_tags = array_merge($cache_tags, $plan_entity->getCacheTags());
      $title = $plan_entity->label();
      if ($plan_entity->field_plan_id && !$plan_entity->field_plan_id->isEmpty()) {
        $icon = $q->getPlanIcon($plan_entity->field_plan_id->value);
        if ($icon) {
          $title = new FormattableMarkup($icon, []);
        }
      }

      $children[] = [
        'title' => $title,
        'url' => $plan_entity->toUrl(),
        'attributes' => [
          'class' => [],
        ],
      ];
    }

    $output['links_plan_entities'] = [
      '#theme' => 'links',
      '#links' => $children,
      '#attributes' => [
        'class' => [
          'links--plan-entities',
        ],
      ],
      '#cache' => [
        'tags' => $cache_tags,
      ],
    ];
  }

  return $output;
}
