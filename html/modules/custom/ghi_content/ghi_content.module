<?php

/**
 * @file
 * Hook implementations for GHI Content.
 */

use Drupal\Core\Batch\BatchBuilder;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\ghi_content\ContentManager\ArticleManager;
use Drupal\ghi_content\Controller\MigrationBatchController;
use Drupal\ghi_sections\SectionManager;
use Drupal\layout_builder\Plugin\SectionStorage\OverridesSectionStorage;
use Drupal\node\NodeInterface;

/**
 * Implements hook_cron().
 */
function ghi_content_cron() {

}

/**
 * Implements hook_theme().
 */
function ghi_content_theme($existing, $type, $theme, $path) {
  return [
    'article_collection_cards' => [
      'variables' => [
        'articles' => [],
        'options' => [
          'alignment' => 'horizontal',
          'columns' => 3,
          'featured' => NULL,
        ],
      ],
      'file' => 'ghi_content.theme.inc',
      'template' => 'article-collection-cards',
    ],
    'article_collection_table' => [
      'variables' => [
        'articles' => [],
      ],
      'file' => 'ghi_content.theme.inc',
      'template' => 'article-collection-table',
    ],
    'related_articles_cards' => [
      'variables' => [
        'articles' => [],
      ],
      'file' => 'ghi_content.theme.inc',
      'template' => 'related-articles-cards',
    ],
  ];
}

/**
 * Implements hook_batch_alter().
 */
function ghi_content_batch_alter(&$batch) {
  $targeted_migration = 'articles_gho';
  $operations = &$batch['sets'][0]['operations'];
  if ($operations[0][0] != '\Drupal\migrate_tools\MigrateBatchExecutable::batchProcessImport' || $operations[0][1][0] != $targeted_migration) {
    return;
  }
  // Add a post-process batch set to article imports to make sure that articles
  // that are not available on the remote source anymore will get unpublished.
  $placeholders = [
    '@name' => $targeted_migration,
  ];
  $batch_builder = (new BatchBuilder())
    ->setTitle(t('Post process @name', $placeholders))
    ->setInitMessage(t('Start post-processing for @name', $placeholders))
    ->setProgressMessage(t('Post-processing @name', $placeholders))
    ->addOperation(
        [MigrationBatchController::class, 'batchProcessCleanupArticles'],
        [$operations[0][1][0], $operations[0][1][1]]
      )
    ->setFinishCallback([MigrationBatchController::class, 'batchFinished']);
  batch_set($batch_builder->toArray());
}

/**
 * Implements hook_contextual_links_alter().
 *
 * Disable contextual links to declutter the interface. If it wouldn't be for
 * layout builder who needs the contextual links for it's own interface, we
 * could just disable the module entirely.
 * See https://www.drupal.org/project/drupal/issues/3042516
 */
function ghi_content_contextual_links_alter(array &$links, $group, array $route_parameters) {
  $allowed_groups = ['layout_builder_block'];
  if (!in_array($group, $allowed_groups)) {
    return;
  }
  /** @var \Drupal\ghi_content\ContextualLinks\BlockHandler $contextual_links_block_handler */
  $contextual_links_block_handler = \Drupal::service('ghi_content.contextual_links.block_handler');
  $contextual_links_block_handler->alterLinks($links, $group, $route_parameters);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Used to disable fields that automatically populated.
 */
function ghi_content_form_node_article_edit_form_alter(array &$form, FormStateInterface $form_state) {
  $disable_fields = [
    'title',
    'langcode',
    'field_image',
    'field_summary',
    'field_tags',
  ];
  foreach ($disable_fields as $field_name) {
    $form[$field_name]['#disabled'] = TRUE;
    $form[$field_name]['#attributes']['title'] = t('This field is disabled because it is automatically populated from the remote source.');
  }
  // Also disable the remote article field.
  $remote_field = ArticleManager::REMOTE_ARTICLE_FIELD;
  $form[$remote_field]['#disabled'] = TRUE;
  $form[$remote_field]['#attributes']['title'] = t('This field cannot be edited anymore after an article page has been created.');
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function ghi_content_node_presave(NodeInterface $node) {
  $remote_field = ArticleManager::REMOTE_ARTICLE_FIELD;
  if (!$node->hasField($remote_field) || !$node->hasField(OverridesSectionStorage::FIELD_NAME)) {
    return;
  }

  /** @var \Drupal\ghi_content\RemoteSource\RemoteSourceManager $remote_source_manager */
  $remote_source_manager = \Drupal::service('plugin.manager.remote_source');

  /** @var \Drupal\ghi_content\Import\ImportManager $import_manager */
  $import_manager = \Drupal::service('ghi_content.import');

  $remote_source = $node->get($remote_field)->remote_source;
  $article_id = $node->get($remote_field)->article_id;

  $remote_source_original = $node->original ? $node->original->get($remote_field)->remote_source : NULL;
  $article_id_original = $node->original ? $node->original->get($remote_field)->article_id : NULL;

  $cleanup = $remote_source_original && $article_id_original && ($remote_source != $remote_source_original || $article_id != $article_id_original);

  /** @var \Drupal\ghi_content\RemoteSource\RemoteSourceInterface $remote_source_instance */
  $remote_source_instance = $remote_source_manager->createInstance($remote_source);
  $article = $remote_source_instance->getArticle($article_id);
  if ($article) {

    // Import the image.
    $import_manager->importImage($node, $article, 'field_image');

    // Import the image.
    $import_manager->importSummary($node, $article, 'field_summary');

    // Import the paragraphs for the article.
    $import_manager->importParagraphs($node, $article, [], NULL, $cleanup);

    // Import the tags.
    $import_manager->importTags($node, $article, 'field_tags');
  }

  if ($node->isNew()) {
    $import_manager->setupRelatedArticlesElement($node, $article);
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for node entities.
 */
function ghi_content_node_predelete(NodeInterface $node) {
  /** @var \Drupal\ghi_content\ContentManager\ArticleManager $article_manager */
  $article_manager = \Drupal::getContainer()->get('ghi_content.manager.article');
  $article_manager->cleanupArticleOnDelete($node);
}

/**
 * Implements hook_preprocess_page().
 *
 * This is used to add the configured hero image (or a default image) to the
 * page title region.
 *
 * This code assumes that there is a page_title region in the theme.
 */
function ghi_content_preprocess_page(&$variables) {
  $region_name = 'page_title';
  if (!array_key_exists($region_name, $variables['page'])) {
    return;
  }

  $request_stack = \Drupal::requestStack();
  $request = $request_stack->getMasterRequest();
  /** @var \Drupal\node\Entity\Node $node */
  $node = $request->attributes->has('node') ? $request->attributes->get('node') : NULL;
  if (!$node instanceof NodeInterface || !$node->getFieldDefinitions()) {
    return;
  }

  if ($node->bundle() != ArticleManager::ARTICLE_BUNDLE || !$node->access()) {
    return;
  }

  // We do not check if the field has actual values, because we might want to
  // show a default image.
  $image_field = $node->get('field_image');
  if ($image_field->isEmpty()) {
    // Don't show default images in the page view.
    return;
  }
  // Get the image for the current page.
  $image = $image_field->view();
  if ($image) {
    $image['#label_display'] = 'hidden';
    array_unshift($variables['page'][$region_name], $image);
  }

}

/**
 * Implements hook_preprocess_views_view_field().
 *
 * This is used to remove the section tags from the tags field in views that
 * take tag ids as an argument in order to show articles belonging to a
 * specific section.
 */
function ghi_content_preprocess_views_view_field__field_tags(&$variables) {
  $valid_view_ids = ['articles_by_tags'];
  /** @var \Drupal\views\ViewExecutable $view */
  $view = $variables['view'];
  if (!in_array($view->storage->id(), $valid_view_ids)) {
    return;
  }

  /** @var \Drupal\views\ResultRow $row */
  $row = $variables['row'];
  /** @var \Drupal\views\Plugin\views\field\EntityField $field */
  $field = $variables['field'];

  // Get the tags that are specific to each row and remove the term ids passed
  // in as arguments.
  $tags = array_diff($field->getValue($row), $view->args);

  // Get the build items from the field and filter it be restricted to these
  // tags.
  $items = $field->getItems($row);
  $items = array_filter($items, function ($item) use ($tags) {
    return in_array($item['raw']->entity->id(), $tags);
  });

  // Then render again according to the options set in the view and overwrite
  // the output.
  $build = $field->renderItems(array_map(function ($item) {
    return $item['rendered'];
  }, $items));
  $variables['output'] = $build;

}

/**
 * Implements hook_local_actions_render_alter().
 *
 * This depends on https://www.drupal.org/project/drupal/issues/2585169.
 */
function ghi_content_local_actions_render_alter(&$data, $route_appears) {
  $supported_routes = [
    'ghi_content.article_update',
    'ghi_content.node.article_update',
  ];
  foreach ($data as $link_key => &$element) {
    if (!in_array($link_key, $supported_routes)) {
      continue;
    }

    $migrate_last_imported_store = \Drupal::keyValue('migrate_last_imported');
    $last_imported = $migrate_last_imported_store->get('articles_gho');
    $last_imported = $last_imported ? intval($last_imported / 1000) : NULL;

    /** @var \Drupal\Core\Datetime\DateFormatterInterface $date_formatter */
    $date_formatter = \Drupal::service('date.formatter');

    if ($last_imported) {
      $element['#link']['title'] = new TranslatableMarkup('@link_title<div class="article-update-info">Last updated: @last_updated ago</div>', [
        '@link_title' => $element['#link']['title'],
        '@last_updated' => $date_formatter->formatTimeDiffSince($last_imported),
      ]);
      $element['#cache'] = ['max-age' => 0];
      $element['#attached']['library'][] = 'ghi_content/admin.article_list';
    }
  }
}

/**
 * Implements hook_entity_operation().
 */
function ghi_content_entity_operation(EntityInterface $entity) {
  $account = \Drupal::currentUser();
  if (!$entity instanceof NodeInterface || !in_array($entity->bundle(), SectionManager::SECTION_BUNDLES)) {
    return;
  }

  $route_name = 'ghi_content.node.articles';
  $route_parameters = [
    'node' => $entity->id(),
  ];

  // If current user has access to route, then add the operation link.
  /** @var \Drupal\Core\Access\AccessManagerInterface $access_manager */
  $access_manager = \Drupal::service('access_manager');
  if (!$access_manager->checkNamedRoute($route_name, $route_parameters, $account)) {
    return;
  }

  return [
    'articles' => [
      'title' => t('Articles'),
      'weight' => 50,
      'url' => Url::fromRoute($route_name, $route_parameters),
    ],
  ];
}

// @codingStandardsIgnoreStart
// /**
//  * Implements hook_node_access_records().
//  *
//  * The basic logic for the moment is that users with edit access to a section
//  * should be able to view any articles listed in that section, whether
//  * published or unpublished.
//  */
// function ghi_content_node_access_records(NodeInterface $node) {
//   $grants = [];
//   if ($node->bundle() != ArticleManager::ARTICLE_BUNDLE || $node->isPublished()) {
//     // Not an article node or already published.
//     return $grants;
//   }

//   /** @var \Drupal\ghi_content\ContentManager\ArticleManager */
//   $article_manager = \Drupal::service('ghi_content.manager.article');
//   $sections = $article_manager->loadSectionsForNode($node);
//   if (empty($sections)) {
//     return $grants;
//   }

//   // Grant view access to all unpublished articles of a section.
//   foreach ($sections as $section) {
//     $grants[] = [
//       'realm' => 'ghi_content_article_access',
//       'gid' => $section->id(),
//       'grant_view' => 1,
//       'grant_update' => 0,
//       'grant_delete' => 0,
//       'priority' => 0,
//     ];
//   }
//   return $grants;
// }

// /**
//  * Implements hook_node_grants().
//  */
// function ghi_content_node_grants(AccountInterface $account, $op) {
//   $grants = [];
//   $grants['ghi_content_article_access'] = [0];

//   $user = User::load($account->id());
//   if (!$user->hasField('field_team') || $user->get('field_team')->isEmpty()) {
//     return $grants;
//   }

//   /** @var \Drupal\ghi_sections\SectionManager */
//   $section_manager = \Drupal::service('ghi_sections.manager');

//   // Load the available sections for the users team.
//   $sections = $section_manager->loadSectionsForTeam($user->field_team->entity);
//   foreach ($sections as $section) {
//     $grants['ghi_content_article_access'][] = $section->id();
//   }
//   return $grants;
// }
// @codingStandardsIgnoreEnd
