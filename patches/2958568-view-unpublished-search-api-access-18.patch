diff --git a/composer.json b/composer.json
index 71d1c19..2ba3cec 100644
--- a/composer.json
+++ b/composer.json
@@ -2,6 +2,7 @@
     "name": "drupal/view_unpublished",
     "type": "drupal-module",
     "description": "Select which roles should be able to see unpublished nodes.",
+    "homepage": "https://www.drupal.org/project/view_unpublished",
     "license": "GPL-2.0-or-later",
     "authors": [
         {
@@ -9,7 +10,11 @@
             "email": "amaria@chisholmtech.com"
         }
     ],
+    "require": {
+        "drupal/core": "^9.4 || ^10"
+    },
     "require-dev": {
+        "drupal/search_api": "^1.26",
         "phpcompatibility/php-compatibility": "10.x-dev@dev",
         "drupal/coder": "^8.3.18"
     }
diff --git a/src/Plugin/search_api/processor/ViewUnpublished.php b/src/Plugin/search_api/processor/ViewUnpublished.php
new file mode 100644
index 0000000..b6d12e3
--- /dev/null
+++ b/src/Plugin/search_api/processor/ViewUnpublished.php
@@ -0,0 +1,256 @@
+<?php
+
+namespace Drupal\view_unpublished\Plugin\search_api\processor;
+
+use Drupal\Core\Session\AccountInterface;
+use Drupal\search_api\Plugin\search_api\processor\ContentAccess;
+use Drupal\search_api\Query\QueryInterface;
+use Drupal\view_unpublished\ViewUnpublishedPermissions;
+use Drupal\node\Entity\NodeType;
+
+/**
+ * Extends default content access permissions to work with "View Unpublished".
+ *
+ * This processor is hidden from the UI because it automatically replaces the
+ * default "content_access" processor (this happens in
+ * view_unpublished_search_api_processor_info_alter()). Doing so enables this
+ * module to have an immediate effect on searches without site builders having
+ * to reconfigure their search indices.
+ *
+ * Beyond simplicity for admins, there's an additional reason we replace the
+ * default handler: if this handler were used as a separate "view_unpublished"
+ * processor, then search_api_node_access_records_alter() would not
+ * automatically update the search index because it's hardcoded to only apply
+ * for the "content_access" processor.
+ *
+ * @SearchApiProcessor(
+ *   id = "view_unpublished",
+ *   label = @Translation("Content access with support for &quot;View Unpublished&quot;"),
+ *   description = @Translation("Extends content access checks for nodes and comments to work with the &quot;View Unpublished&quot; module.<br /><strong>This replaces the standard &quot;Content access&quot; processor from Search API.</strong>"),
+ *   stages = {
+ *     "add_properties" = 0,
+ *     "pre_index_save" = -10,
+ *     "preprocess_query" = -30,
+ *   },
+ *   locked = false,
+ *   hidden = true,
+ * )
+ * @noinspection PhpUnused
+ */
+class ViewUnpublished extends ContentAccess {
+
+  /**
+   * {@inheritdoc}
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *   If the required "type" field is missing and cannot be added.
+   */
+  public function preIndexSave() {
+    parent::preIndexSave();
+
+    foreach ($this->index->getDatasources() as $datasource_id => $datasource) {
+      $entity_type = $datasource->getEntityTypeId();
+
+      if ($entity_type == 'node') {
+        // Ensure node content type/bundle is indexed, for use in access checks.
+        $this->ensureField($datasource_id, 'type', 'string');
+      }
+    }
+  }
+
+  /**
+   * Check if an account has any of the permission defined by this module.
+   *
+   * @param \Drupal\Core\Session\AccountInterface $account
+   *   The current user.
+   *
+   * @return bool
+   *   TRUE if the logged-in user has one of the permissions exposed by this
+   *   module; or, FALSE, if they do not.
+   */
+  protected function hasAnyUnpublishedPermission(AccountInterface $account): bool {
+    if ($account->hasPermission("view any unpublished content")) {
+      return TRUE;
+    }
+
+    $permission_manager = new ViewUnpublishedPermissions();
+    foreach ($permission_manager->permissions() as $key => $value) {
+      if ($account->hasPermission($key)) {
+        return TRUE;
+      }
+    }
+
+    return FALSE;
+  }
+
+  /**
+   * {@inheritDoc}
+   *
+   * This revises access checks to allow authorized users to view unpublished
+   * content.
+   *
+   * @see \Drupal\search_api\Plugin\search_api\processor\ContentAccess::addNodeAccess()
+   *
+   * @noinspection DuplicatedCode
+   * @noinspection SpellCheckingInspection
+   * @phpcs:disable Drupal.Commenting.InlineComment.SpacingBefore
+   */
+  protected function addNodeAccess(QueryInterface $query, AccountInterface $account) {
+    if (!$this->hasAnyUnpublishedPermission($account)) {
+      // For performance, skip our checks and defer to the parent implementation
+      // if the account has none of the permissions granted by this module.
+      parent::addNodeAccess($query, $account);
+      return;
+    }
+
+    // Don't do anything if the user can access all content.
+    if ($account->hasPermission('bypass node access')) {
+      return;
+    }
+
+    // Gather the affected datasources, grouped by entity type, as well as the
+    // unaffected ones.
+    $affected_datasources = [];
+    $unaffected_datasources = [];
+    foreach ($this->index->getDatasources() as $datasource_id => $datasource) {
+      $entity_type = $datasource->getEntityTypeId();
+      if (in_array($entity_type, ['node', 'comment'])) {
+        $affected_datasources[$entity_type][] = $datasource_id;
+      }
+      else {
+        $unaffected_datasources[] = $datasource_id;
+      }
+    }
+
+    // The filter structure we want looks like this:
+    //   [belongs to other datasource]
+    //   OR
+    //   (
+    //     [is enabled (or was created by the user, if applicable)]
+    //     AND
+    //     [grants view access to one of the user's gid/realm combinations]
+    //   )
+    // If there are no "other" datasources, we don't need the nested OR,
+    // however, and can add the inner conditions directly to the query.
+    if (empty($unaffected_datasources)) {
+      $access_conditions = $query;
+    }
+    else {
+      $outer_conditions = $query->createConditionGroup('OR', ['content_access']);
+      $query->addConditionGroup($outer_conditions);
+
+      foreach ($unaffected_datasources as $datasource_id) {
+        $outer_conditions->addCondition('search_api_datasource', $datasource_id);
+      }
+
+      // phpcs:ignore Drupal.Commenting.InlineComment.DocBlock
+      /** @noinspection PhpRedundantOptionalArgumentInspection */
+      $access_conditions = $query->createConditionGroup('AND');
+      $outer_conditions->addConditionGroup($access_conditions);
+    }
+
+    if (!$account->hasPermission('access content')) {
+      unset($affected_datasources['node']);
+    }
+    if (!$account->hasPermission('access comments')) {
+      unset($affected_datasources['comment']);
+    }
+
+    // If the user does not have the permission to see any content at all, deny
+    // access to all items from affected datasources.
+    if (empty($affected_datasources)) {
+      // If there were "other" datasources, the existing filter will already
+      // remove all results of node or comment datasources. Otherwise, we should
+      // not return any results at all.
+      if (empty($unaffected_datasources)) {
+        $query->abort($this->t('You have no access to any results in this search.'));
+      }
+      return;
+    }
+
+    if (!$account->hasPermission('view any unpublished content')) {
+      // This user doesn't have permission to view all unpublished things. We
+      // can only show them things that meet the following criteria:
+      // 1. The content is published; OR
+      // 2. The content is unpublished, but:
+      //    a. The user has permission to see own unpublished content and this
+      //       content was authored by this user.
+      //    b. The user has permission to see unpublished content of this type
+      //       of content.
+      $publish_conditions = $query->createConditionGroup('OR', ['content_access_enabled']);
+      $has_unpublished_own = $account->hasPermission('view own unpublished content');
+
+      foreach ($affected_datasources as $entity_type => $datasources) {
+        foreach ($datasources as $datasource_id) {
+          // 1. Allow users to see content that's been published.
+          //
+          // If this is a comment datasource, or users cannot view their own
+          // unpublished nodes, a simple filter on "status" is enough.
+          // Otherwise, it's a bit more complicated.
+          $status_field = $this->findField($datasource_id, 'status', 'boolean');
+          if ($status_field !== NULL) {
+            $publish_conditions->addCondition(
+              $status_field->getFieldIdentifier(),
+              TRUE
+            );
+          }
+
+          if ($entity_type == 'node') {
+            // 2(a). If the user has permission to see their own unpublished
+            // content, allow them to see any unpublished content where they're
+            // the author.
+            if ($has_unpublished_own) {
+              $author_field = $this->findField($datasource_id, 'uid', 'integer');
+
+              if ($author_field !== NULL) {
+                $publish_conditions->addCondition(
+                  $author_field->getFieldIdentifier(),
+                  $account->id()
+                );
+              }
+            }
+
+            // 2(b). Allow the user to see unpublished content of the types that
+            // they've been granted to see.
+            $content_type_field = $this->findField($datasource_id, 'type', 'string');
+            if ($content_type_field !== NULL) {
+              foreach (NodeType::loadMultiple() as $type) {
+                $type_id = $type->id();
+
+                if ($account->hasPermission("view any unpublished $type_id content")) {
+                  $publish_conditions->addCondition(
+                    $content_type_field->getFieldIdentifier(),
+                    $type_id
+                  );
+                }
+              }
+            }
+          }
+        }
+      }
+
+      $access_conditions->addConditionGroup($publish_conditions);
+    }
+
+    // Filter by the user's node access grants.
+    $node_grants_field = $this->findField(NULL, 'search_api_node_grants', 'string');
+    if ($node_grants_field === NULL) {
+      return;
+    }
+
+    $node_grants_field_id = $node_grants_field->getFieldIdentifier();
+    $grants_conditions = $query->createConditionGroup('OR', ['content_access_grants']);
+    $grants = node_access_grants('view', $account);
+    foreach ($grants as $realm => $gids) {
+      foreach ($gids as $gid) {
+        $grants_conditions->addCondition($node_grants_field_id, "node_access_$realm:$gid");
+      }
+    }
+
+    // Also add items that are accessible for everyone by checking the "access
+    // all" pseudo grant.
+    $grants_conditions->addCondition($node_grants_field_id, 'node_access__all');
+    $access_conditions->addConditionGroup($grants_conditions);
+  }
+
+}
diff --git a/tests/src/Kernel/Plugin/search_api/Processor/ViewUnpublishedContentAccessTest.php b/tests/src/Kernel/Plugin/search_api/Processor/ViewUnpublishedContentAccessTest.php
new file mode 100644
index 0000000..05ead26
--- /dev/null
+++ b/tests/src/Kernel/Plugin/search_api/Processor/ViewUnpublishedContentAccessTest.php
@@ -0,0 +1,1061 @@
+<?php
+
+namespace Drupal\Tests\view_unpublished\Kernel\Plugin\search_api\Processor;
+
+use Drupal\comment\CommentInterface;
+use Drupal\comment\Entity\Comment;
+use Drupal\comment\Entity\CommentType;
+use Drupal\comment\Tests\CommentTestTrait;
+use Drupal\Core\Database\Database;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Session\AnonymousUserSession;
+use Drupal\node\Entity\Node;
+use Drupal\node\Entity\NodeType;
+use Drupal\node\NodeInterface;
+use Drupal\search_api\IndexInterface;
+use Drupal\search_api\Query\QueryInterface;
+use Drupal\search_api\Query\ResultSetInterface;
+use Drupal\search_api\Utility\Utility;
+use Drupal\Tests\search_api\Kernel\Processor\ProcessorTestBase;
+use Drupal\Tests\user\Traits\UserCreationTrait;
+use Drupal\user\Entity\Role;
+use Drupal\user\UserInterface;
+use Drupal\view_unpublished\Plugin\search_api\processor\ViewUnpublished;
+
+/**
+ * Tests the "Content access with support for 'View Unpublished'" processor.
+ *
+ * This processor extends the "Content access" processor that's built into
+ * Search API so that it is aware of additional permissions defined by
+ * "View Unpublished", so a lot of these tests are borrowed from the tests for
+ * the base processor.
+ *
+ * @group view_unpublished
+ *
+ * @requires module search_api
+ *
+ * @see \Drupal\view_unpublished\Plugin\search_api\processor\ViewUnpublished
+ * @see \Drupal\search_api\Plugin\search_api\processor\ContentAccess
+ * @see \Drupal\Tests\search_api\Kernel\Processor\ContentAccessTest
+ */
+class ViewUnpublishedContentAccessTest extends ProcessorTestBase {
+
+  use CommentTestTrait;
+  use UserCreationTrait {
+    createUser as baseCreateUser;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected static $modules = [
+    'view_unpublished',
+  ];
+
+  /**
+   * The nodes created for testing.
+   *
+   * @var \Drupal\node\NodeInterface[]|null
+   */
+  protected ?array $nodes;
+
+  /**
+   * The comments created for testing.
+   *
+   * @var \Drupal\comment\CommentInterface[]|null
+   */
+  protected ?array $comments;
+
+  /**
+   * The users created for testing.
+   *
+   * @var \Drupal\user\UserInterface[]|null
+   */
+  protected ?array $users;
+
+  /**
+   * A moderator user who can only view unpublished "blog" content.
+   *
+   * @var \Drupal\user\UserInterface|null
+   */
+  protected ?UserInterface $blogModeratorUser;
+
+  /**
+   * A moderator user who can view all unpublished content.
+   *
+   * @var \Drupal\user\UserInterface|null
+   */
+  protected ?UserInterface $fullModeratorUser;
+
+  /**
+   * {@inheritdoc}
+   *
+   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function setUp($processor = NULL): void {
+    // This is not a typo -- the "views_unpublished" processor overrides the
+    // default "content_access" processor. We could put "views_unpublished" here
+    // but then testNodeGrantsChange() would fail because
+    // search_api_node_access_records_alter() is hard-coded to look for the
+    // specific ID of the "content_access" processor.
+    parent::setUp('content_access');
+
+    $this->nodes    = [];
+    $this->comments = [];
+    $this->users    = [];
+
+    // Activate a custom grant that prevents all users except the original
+    // author of a node from viewing it. This only grants access to PUBLISHED
+    // nodes. Users without "view own unpublished content" permission will still
+    // not be able to see nodes they authored if those nodes are unpublished.
+    \Drupal::state()->set('search_api_test_add_node_access_grant', TRUE);
+
+    // Create "page" and "blog" node types for testing.
+    foreach (['page' => 'Page', 'blog' => 'Blog'] as $type_name => $label) {
+      $type = NodeType::create([
+        'type' => $type_name,
+        'name' => $label,
+      ]);
+      $type->save();
+    }
+
+    // Create anonymous user role.
+    $role = Role::create([
+      'id'    => 'anonymous',
+      'label' => 'anonymous',
+    ]);
+    $role->save();
+
+    // User Index 0: The anonymous user. We have to insert them because the user
+    // table is inner-joined by \Drupal\comment\CommentStorage.
+    $this->createUser([], '', FALSE, ['uid' => 0, 'name' => '']);
+
+    // User Index 1: A moderator who can access unpublished "blog" content.
+    $this->blogModeratorUser = $this->createUser([
+      'view any unpublished blog content',
+    ]);
+
+    // User Index 2: A moderator who can access all unpublished content.
+    $this->fullModeratorUser = $this->createUser([
+      'view any unpublished content',
+    ]);
+
+    // Setup support for comments on page nodes.
+    $this->installConfig(['comment']);
+    $comment_type = CommentType::create([
+      'id'                    => 'comment',
+      'target_entity_type_id' => 'node',
+    ]);
+    $comment_type->save();
+    $this->addDefaultCommentField('node', 'page');
+
+    // Node Index 0: A published node with an attached, published comment.
+    $this->createNode([
+      'status' => NodeInterface::PUBLISHED,
+      'type'   => 'page',
+      'title'  => 'test title',
+    ]);
+    // Comment Index 0: A published comment on Node #0.
+    $this->createComment([
+      'status'       => CommentInterface::PUBLISHED,
+      'entity_type'  => 'node',
+      'entity_id'    => $this->nodes[0]->id(),
+      'field_name'   => 'comment',
+      'body'         => 'test body',
+      'comment_type' => $comment_type->id(),
+    ]);
+
+    // Node Index 1: A published page node.
+    $this->createNode([
+      'status' => NodeInterface::PUBLISHED,
+      'type'   => 'page',
+      'title'  => 'some title',
+    ]);
+
+    // Node Index 2: An unpublished page node.
+    $this->createNode([
+      'status' => NodeInterface::NOT_PUBLISHED,
+      'type'   => 'page',
+      'title'  => 'other title',
+    ]);
+
+    // Also index users, to verify that they are unaffected by the processor.
+    assert($this->index instanceof IndexInterface);
+    $dataSources = \Drupal::getContainer()
+      ->get('search_api.plugin_helper')
+      ->createDatasourcePlugins($this->index, [
+        'entity:comment',
+        'entity:node',
+        'entity:user',
+      ]);
+    $this->index->setDatasources($dataSources);
+    $this->index->save();
+
+    \Drupal::getContainer()
+      ->get('search_api.index_task_manager')
+      ->addItemsAll($this->index);
+    $index_storage = \Drupal::entityTypeManager()->getStorage('search_api_index');
+    $index_storage->resetCache([$this->index->id()]);
+    $this->index = $index_storage->load($this->index->id());
+  }
+
+  /**
+   * Tests that the "content_access" processor gets replaced by ours.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testContentAccessProcessorReplacement() {
+    $processor = $this->index->getProcessor('content_access');
+
+    $this->assertInstanceOf(
+      ViewUnpublished::class,
+      $processor,
+      'The "content_access" processor from Search API gets replaced with the custom version from "View Unpublished".'
+    );
+  }
+
+  /**
+   * Tests searching published content accessible to all w/out. VU perms.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testQueryAccessAllWithoutViewUnpublishedPerms() {
+    $permissions = [
+      'access content',
+      'access comments',
+    ];
+    user_role_grant_permissions('anonymous', $permissions);
+
+    // Total of 7 items: 3 nodes + 1 comment + 3 users.
+    $this->indexContentAndAssertCount(7);
+
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes. Search API provides a default node access grant for the
+    // anonymous user account not to have any content restrictions (independent
+    // of the published access requirement).
+    $expected = [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+      'node'    => [0, 1],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests searching published content accessible to all w/. VU perms.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   * @noinspection PhpConditionAlreadyCheckedInspection
+   */
+  public function testQueryAccessAllWithViewUnpublishedPerms() {
+    // Total of 7 items: 3 nodes + 1 comment + 3 users.
+    $this->indexContentAndAssertCount(7);
+
+    // Grant users permission to see everything but unpublished pages and
+    // confirm they can see all published content.
+    user_role_grant_permissions('anonymous', [
+      'access content',
+      'access comments',
+      'view any unpublished blog content',
+    ]);
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes. Search API provides a default node access grant for the
+    // anonymous user account not to have any content restrictions (independent
+    // of the published access requirement).
+    $expected = [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+      'node'    => [0, 1],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Now, grant the user permission to see unpublished 'page' content and
+    // confirm they can access all the nodes.
+    user_role_grant_permissions('anonymous', [
+      'view any unpublished page content',
+    ]);
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $expected = [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+      'node'    => [0, 1, 2],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests searching when only comments are accessible.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testQueryAccessCommentsWithoutViewUnpublishedPerms() {
+    user_role_grant_permissions('anonymous', ['access comments']);
+
+    // Total of 7 items: 3 nodes + 1 comment + 3 users.
+    $this->indexContentAndAssertCount(7);
+
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->comments.
+    $this->assertResults($result, [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+    ]);
+  }
+
+  /**
+   * Tests searching when only comments are accessible and user has VU perms.
+   *
+   * This creates a user having one of the permissions from "View Unpublished"
+   * and confirms that the extended processor provided by this module enables
+   * a user to view published comments even if the only way that content is
+   * accessible to the user is because it is published.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testQueryAccessCommentsWithViewUnpublishedPerms() {
+    // Total of 7 items: 3 nodes + 1 comment + 3 users.
+    $this->indexContentAndAssertCount(7);
+
+    // Grant users permission to see everything but unpublished pages and
+    // confirm they can see all published content.
+    user_role_grant_permissions('anonymous', [
+      'access comments',
+      'view any unpublished blog content',
+    ]);
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $this->assertResults($result, [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+    ]);
+
+    // Now, grant the user permission to see unpublished 'page' content and
+    // confirm it has no impact on node access when the user lacks permission
+    // to view content.
+    user_role_grant_permissions('anonymous', [
+      'view any unpublished page content',
+    ]);
+    $query  = $this->buildQuery();
+    $result = $query->execute();
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $this->assertResults($result, [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+    ]);
+  }
+
+  /**
+   * Tests searching for own unpublished content w/out. VU perms.
+   *
+   * This creates a user with none of the permissions from "View Unpublished"
+   * and confirms that base functionality works when using the replacement
+   * processor provided by this module.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testQueryAccessWithViewOwnUnpublishedAndWithoutViewUnpublishedPerms() {
+    // User Index 3: A user who can access their own unpublished content.
+    $author_user = $this->createUser([
+      'access content',
+      'access comments',
+      'view own unpublished content',
+    ]);
+
+    // Node Index 3: An unpublished node authored by user #3.
+    $this->createNode([
+      'status' => NodeInterface::NOT_PUBLISHED,
+      'type'   => 'page',
+      'title'  => 'foo',
+      'uid'    => $author_user->id(),
+    ]);
+
+    // Total of 9 items: 4 nodes + 1 comment + 4 users.
+    $this->indexContentAndAssertCount(9);
+
+    $query = $this->buildQuery(['search_api_access_account' => $author_user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    // Because node 3 is unpublished, the custom Search API node access grant
+    // is not enough to allow access to the node. So, if the node appears in
+    // results, that means the author's permissions are allowing them to see
+    // the content.
+    $expected = [
+      'user' => [0, 1, 2, 3],
+      'node' => [3],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Revoke the permission to view unpublished content from the author and
+    // confirm they can no longer search their unpublished content.
+    $this->revokePermission($author_user, 'view own unpublished content');
+    $query = $this->buildQuery(['search_api_access_account' => $author_user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    // Because node 3 is unpublished, the custom Search API node access grant
+    // is not enough to allow access to the node. Now that the user has lost
+    // permission to see their own unpublished content, the node they authored
+    // should not appear.
+    $expected = [
+      'user' => [0, 1, 2, 3],
+      'node' => [],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests searching for own unpublished content with VU perms.
+   *
+   * This creates two users with one of the permissions from "View Unpublished"
+   * and confirms that the extended processor provided by this module enables
+   * a user to view their own unpublished content even if the only way that
+   * content is accessible to the user is because they are the author.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   * @noinspection PhpConditionAlreadyCheckedInspection
+   */
+  public function testQueryAccessWithViewOwnUnpublishedAndViewUnpublishedPerms() {
+    $shared_permissions = [
+      'access content',
+      'access comments',
+      'view own unpublished content',
+      'view any unpublished blog content',
+    ];
+
+    // User Indices 3 and 4: Two users who can access their own unpublished
+    // content and unpublished *blog* content, but not unpublished *page*
+    // content.
+    $author_user = $this->createUser($shared_permissions);
+    $other_user  = $this->createUser($shared_permissions);
+
+    // We make the content authored only by the first user.
+    $author_uid = $author_user->id();
+
+    // Node Index 3: An unpublished node authored by user #3.
+    $this->createNode([
+      'status' => NodeInterface::NOT_PUBLISHED,
+      'type'   => 'page',
+      'title'  => 'foo',
+      'uid'    => $author_uid,
+    ]);
+
+    // Total of 10 items: 4 nodes + 1 comment + 5 users.
+    $this->indexContentAndAssertCount(10);
+
+    // Perform a query as the first user, who was the author of the page.
+    $query = $this->buildQuery(['search_api_access_account' => $author_user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    // Because node 3 is unpublished, the custom Search API node access grant
+    // is not enough to allow access to the node. So, if the node appears in
+    // results, that means the author's permissions are allowing them to see
+    // the content.
+    $expected = [
+      'user' => [0, 1, 2, 3, 4],
+      'node' => [3],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Perform a query as the second user, who is NOT the author of the page.
+    $query = $this->buildQuery(['search_api_access_account' => $other_user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    // Because of the custom Search API node access grant, this user has no
+    // default access to any of the published nodes.
+    $expected = [
+      'user' => [0, 1, 2, 3, 4],
+      'node' => [],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Revoke the permission to view unpublished content from the author and
+    // confirm they can no longer search their unpublished content.
+    $this->revokePermission($author_user, 'view own unpublished content');
+    $query = $this->buildQuery(['search_api_access_account' => $author_user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    // Because node 3 is unpublished, the custom Search API node access grant
+    // is not enough to allow access to the node. Now that the user has lost
+    // permission to see their own unpublished content, the node they authored
+    // should not appear.
+    $expected = [
+      'user' => [0, 1, 2, 3, 4],
+      'node' => [],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests searching for content w/. node grants, w/out. VU perms.
+   *
+   * This creates a user with none of the permissions from "View Unpublished"
+   * but with content that is controlled by node grants, and confirms that base
+   * functionality works when using the replacement processor provided by this
+   * module.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   * @throws \Drupal\search_api\SearchApiException
+   * @throws \Exception
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testQueryAccessWithNodeGrantsWithoutViewUnpublishedPerms() {
+    // User Index #3: A user who can access published content.
+    $user = $this->createUser([
+      'access content',
+    ]);
+
+    Database::getConnection()
+      ->insert('node_access')
+      ->fields([
+        'nid'        => $this->nodes[0]->id(),
+        'langcode'   => $this->nodes[0]->language()->getId(),
+        'gid'        => $user->id(),
+        'realm'      => 'search_api_test',
+        'grant_view' => 1,
+      ])
+      ->execute();
+
+    // Total of 8 items: 3 nodes + 1 comment + 4 users.
+    $this->indexContentAndAssertCount(8);
+
+    $query = $this->buildQuery(['search_api_access_account' => $user]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users and $this->nodes.
+    $expected = [
+      'user' => [0, 1, 2, 3],
+      'node' => [0],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests searching for content w/. node grants and VU perms.
+   *
+   * This creates a user with one of the permissions from "View Unpublished" and
+   * content that is controlled by node grants, and confirms that the extended
+   * processor provided by this module enables a user to view the content
+   * controlled by grants even if the only way that content is accessible to the
+   * user is because of the grants.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   * @throws \Drupal\search_api\SearchApiException
+   * @throws \Exception
+   *
+   * @noinspection DuplicatedCode
+   * @noinspection PhpConditionAlreadyCheckedInspection
+   */
+  public function testQueryAccessWithNodeGrantsWithViewUnpublishedPerms() {
+    // User Index #3: A user who can access published content and unpublished
+    // blog content.
+    $user = $this->createUser([
+      'access content',
+      'view any unpublished blog content',
+    ]);
+
+    Database::getConnection()
+      ->insert('node_access')
+      ->fields([
+        'nid'        => $this->nodes[0]->id(),
+        'langcode'   => $this->nodes[0]->language()->getId(),
+        'gid'        => $user->id(),
+        'realm'      => 'search_api_test',
+        'grant_view' => 1,
+      ])
+      ->execute();
+
+    // Total of 8 items: 3 nodes + 1 comment + 4 users.
+    $this->indexContentAndAssertCount(8);
+
+    // First, test that the grant now allows the user to view node #0.
+    $query = $this->buildQuery(['search_api_access_account' => $user]);
+    $result = $query->execute();
+    // These are indices of entities in $this->users and $this->nodes.
+    $expected = [
+      'user' => [0, 1, 2, 3],
+      'node' => [0],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Now, grant the user permission to see unpublished 'page' content and
+    // confirm it has no impact on what nodes can be seen (since the other nodes
+    // have no grants that allow access to them).
+    $this->grantPermission($user, 'view any unpublished page content');
+    $query  = $this->buildQuery(['search_api_access_account' => $user]);
+    $result = $query->execute();
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $expected = [
+      'user' => [0, 1, 2, 3],
+      'node' => [0],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Tests the indexed and assigned grants w/out. VU perms.
+   *
+   * This checks to ensure that indexing is working properly when using the
+   * replacement processor provided by this module and fetching node grants for
+   * a user without any permissions from "View Unpublished".
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testNodeGrantsWithoutViewUnpublishedPerms() {
+    user_role_grant_permissions('anonymous', [
+      'access content',
+      'access comments',
+    ]);
+
+    // Deactivate our custom grant and re-save the grant records.
+    $this->disableSearchApiNodeAccessGrant();
+
+    $items = [];
+    foreach ($this->comments as $comment) {
+      $items[] = [
+        'datasource' => 'entity:comment',
+        'item'       => $comment->getTypedData(),
+        'item_id'    => $comment->id(),
+        'text'       => 'Comment: ' . $comment->id(),
+      ];
+    }
+    $items = $this->generateItems($items);
+
+    // Add the processor's field values to the items.
+    foreach ($items as $item) {
+      $this->processor->addFieldValues($item);
+    }
+
+    // Verify all items were indexed with the "all" realm grant.
+    $all = ['node_access_all:0'];
+    foreach ($items as $item) {
+      $this->assertEquals($all, $item->getField('node_grants')->getValues());
+    }
+
+    // Verify that the anonymous user has the "all" realm grant plus the general
+    // grant from View Unpublished that allows access to published content.
+    $grants = node_access_grants('view', new AnonymousUserSession());
+    $this->assertEquals(
+      [
+        'all'                                => [0],
+        'view_unpublished_published_content' => [1],
+      ],
+      $grants
+    );
+  }
+
+  /**
+   * Tests the indexed and assigned grants if users have VU perms.
+   *
+   * This checks to ensure that node grant indexing is working properly when
+   * using the replacement processor provided by this module and fetching node
+   * grants for a user having one of the permissions from "View Unpublished".
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testNodeGrantsWithViewUnpublishedPerms() {
+    user_role_grant_permissions('anonymous', [
+      'access content',
+      'access comments',
+      'view any unpublished blog content',
+    ]);
+
+    // Deactivate our custom grant and re-save the grant records.
+    $this->disableSearchApiNodeAccessGrant();
+
+    $items = [];
+    foreach ($this->comments as $comment) {
+      $items[] = [
+        'datasource' => 'entity:comment',
+        'item'       => $comment->getTypedData(),
+        'item_id'    => $comment->id(),
+        'text'       => 'Comment: ' . $comment->id(),
+      ];
+    }
+    $items = $this->generateItems($items);
+
+    // Add the processor's field values to the items.
+    foreach ($items as $item) {
+      $this->processor->addFieldValues($item);
+    }
+
+    // Verify all items were indexed with the "all" realm grant.
+    $all = ['node_access_all:0'];
+    foreach ($items as $item) {
+      $this->assertEquals($all, $item->getField('node_grants')->getValues());
+    }
+
+    // Verify that the anonymous user has the "all" realm grant plus the grants
+    // added by View Unpublished.
+    $grants = node_access_grants('view', new AnonymousUserSession());
+    $this->assertEquals(
+      [
+        'all'                                => [0],
+        'view_unpublished_published_content' => [1],
+        'view_unpublished_blog_content'      => [1],
+      ],
+      $grants
+    );
+  }
+
+  /**
+   * Tests the grants indexed when using a standard hook_node_grants() impl.
+   *
+   * This checks to ensure that node grant indexing is working properly when
+   * using the replacement processor provided by this module.
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testNodeGrantsStandard() {
+    $items = [];
+    foreach ($this->comments as $comment) {
+      $items[] = [
+        'datasource' => 'entity:comment',
+        'item'       => $comment->getTypedData(),
+        'item_id'    => $comment->id(),
+        'field_text' => 'Text: &' . $comment->id(),
+      ];
+    }
+    $items = $this->generateItems($items);
+
+    // Add the processor's field values to the items.
+    foreach ($items as $item) {
+      $this->processor->addFieldValues($item);
+    }
+
+    $grant = ['node_access_search_api_test:0'];
+    foreach ($items as $item) {
+      $this->assertEquals($grant, $item->getField('node_grants')->getValues());
+    }
+  }
+
+  /**
+   * Tests that acquiring grants for a node leads to re-indexing that node.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   */
+  public function testNodeGrantsChange() {
+    $this->index->setOption('index_directly', FALSE)->save();
+    $this->indexItems();
+    $remaining = $this->index->getTrackerInstance()->getRemainingItems();
+    $this->assertEquals([], $remaining, 'All items were indexed.');
+
+    /** @var \Drupal\node\NodeAccessControlHandlerInterface $access_control_handler */
+    $access_control_handler = \Drupal::entityTypeManager()
+      ->getAccessControlHandler('node');
+    $access_control_handler->acquireGrants($this->nodes[0]);
+
+    $expected = [
+      'entity:comment/' . $this->comments[0]->id() . ':en',
+      'entity:node/' . $this->nodes[0]->id() . ':en',
+    ];
+    $remaining = $this->index->getTrackerInstance()->getRemainingItems();
+    sort($remaining);
+    $this->assertEquals($expected, $remaining, 'The expected items were marked as "changed" when changing node access grants.');
+  }
+
+  /**
+   * Tests whether the "search_api_bypass_access" query option is respected.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   *
+   * @noinspection DuplicatedCode
+   * @noinspection PhpConditionAlreadyCheckedInspection
+   */
+  public function testQueryAccessBypass() {
+    // Total of 7 items: 3 nodes + 1 comment + 3 users.
+    $this->indexContentAndAssertCount(7);
+
+    // Query as anonymous user.
+    $query  = $this->buildQuery(['search_api_bypass_access' => TRUE]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $expected = [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+      'node'    => [0, 1, 2],
+    ];
+    $this->assertResults($result, $expected);
+
+    // Query as a user with View Unpublished permissions.
+    $query = $this->buildQuery([
+      'search_api_bypass_access'  => TRUE,
+      'search_api_access_account' => $this->blogModeratorUser,
+    ]);
+    $result = $query->execute();
+
+    // These are indices of entities in $this->users, $this->comments, and
+    // $this->nodes.
+    $expected = [
+      'user'    => [0, 1, 2],
+      'comment' => [0],
+      'node'    => [0, 1, 2],
+    ];
+    $this->assertResults($result, $expected);
+  }
+
+  /**
+   * Rebuilds the index being used for this test and then checks its contents.
+   *
+   * @param int $expected_count
+   *   The expected count of items in the index.
+   *
+   * @throws \Drupal\search_api\SearchApiException
+   */
+  protected function indexContentAndAssertCount(int $expected_count): void {
+    $this->index->reindex();
+    $this->indexItems();
+
+    $this->assertEquals(
+      $expected_count,
+      $this->index->getTrackerInstance()->getIndexedItemsCount(),
+      sprintf('%d items indexed, as expected.', $expected_count)
+    );
+  }
+
+  /**
+   * Builds a new query for the search index.
+   *
+   * @param array $options
+   *   Additional options to set for the query.
+   *
+   * @return \Drupal\search_api\Query\QueryInterface
+   *   The new query.
+   */
+  protected function buildQuery(array $options = []): QueryInterface {
+    return \Drupal::getContainer()
+      ->get('search_api.query_helper')
+      ->createQuery($this->index, $options);
+  }
+
+  /**
+   * Creates a node with the given field values.
+   *
+   * The node is added to the list of nodes created in the current test, for
+   * use with assertResults().
+   *
+   * @param array $values
+   *   The initial node field values.
+   *
+   * @return \Drupal\node\NodeInterface
+   *   The new node.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   If the node cannot be saved.
+   */
+  protected function createNode(array $values): NodeInterface {
+    $node = Node::create($values);
+    $node->save();
+
+    $this->nodes[] = $node;
+
+    return $node;
+  }
+
+  /**
+   * Creates a comment with the given field values.
+   *
+   * The comment is added to the list of comments created in the current test,
+   * for use with assertResults().
+   *
+   * @param array $values
+   *   The initial comment field values.
+   *
+   * @return \Drupal\comment\CommentInterface
+   *   The new comment.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   If the comment cannot be saved.
+   */
+  protected function createComment(array $values): CommentInterface {
+    $comment = Comment::create($values);
+    $comment->save();
+
+    $this->comments[] = $comment;
+
+    return $comment;
+  }
+
+  /**
+   * Create a user with a given set of permissions.
+   *
+   * The user is added to the list of users created in the current test, for
+   * use with assertResults().
+   *
+   * @param array $permissions
+   *   Array of permission names to assign to user. Note that the user always
+   *   has the default permissions derived from the "authenticated users" role.
+   * @param string $name
+   *   The user name.
+   * @param bool $admin
+   *   (optional) Whether the user should be an administrator
+   *   with all the available permissions.
+   * @param array $values
+   *   (optional) An array of initial user field values.
+   *
+   * @return \Drupal\user\Entity\User|false
+   *   A fully loaded user object with pass_raw property, or FALSE if account
+   *   creation fails.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   If the user creation fails.
+   */
+  protected function createUser(array $permissions = [], $name = NULL, $admin = FALSE, array $values = []) {
+    $user = $this->baseCreateUser($permissions, $name, $admin, $values);
+    $this->users[] = $user;
+
+    return $user;
+  }
+
+  /**
+   * Asserts that the search results contain the expected IDs.
+   *
+   * Unlike \Drupal\Tests\search_api\Kernel\ResultsTrait::assertResults(), this
+   * version handles users just like any other type of entity and expects to
+   * find them defined in $this->users. This version also sanity-checks the
+   * passed-in indices to avoid undefined property errors.
+   *
+   * @param \Drupal\search_api\Query\ResultSetInterface $result
+   *   The search results.
+   * @param int[][] $expected
+   *   The expected entity IDs, grouped by entity type and with their indexes in
+   *   this object's respective array properties as the values.
+   */
+  protected function assertResults(ResultSetInterface $result, array $expected) {
+    $results = array_keys($result->getResultItems());
+    sort($results);
+
+    $ids = [];
+    foreach ($expected as $entity_type => $items) {
+      $datasource_id = "entity:$entity_type";
+      foreach ($items as $index) {
+        $property_name = "{$entity_type}s";
+        $entity        = $this->{$property_name}[$index] ?? NULL;
+
+        $this->assertNotNull(
+          $entity,
+          sprintf(
+            'There is no "%s" at index "%d" of "$this->%s"',
+            $entity_type,
+            $index,
+            $property_name
+          )
+        );
+        assert($entity instanceof EntityInterface);
+
+        $id = $entity->id() . ':en';
+        $ids[] = Utility::createCombinedId($datasource_id, $id);
+      }
+    }
+    sort($ids);
+
+    $this->assertEquals($ids, $results);
+  }
+
+  /**
+   * Deactivates the custom grant added during setUp() and then re-saves grants.
+   */
+  protected function disableSearchApiNodeAccessGrant(): void {
+    \Drupal::state()->set('search_api_test_add_node_access_grant', FALSE);
+
+    /** @var \Drupal\node\NodeAccessControlHandlerInterface $access_control_handler */
+    $access_control_handler = \Drupal::entityTypeManager()
+      ->getAccessControlHandler('node');
+    $grants_storage = \Drupal::getContainer()->get('node.grant_storage');
+    foreach ($this->nodes as $node) {
+      $grants = $access_control_handler->acquireGrants($node);
+      $grants_storage->write($node, $grants);
+    }
+  }
+
+  /**
+   * Grants the specified permission to the first non-locked role of a user.
+   *
+   * @param \Drupal\user\UserInterface $user
+   *   The user to which the permission should be granted.
+   * @param string $permission
+   *   The machine name of the permission to grant.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   If the first non-locked user role fails to save.
+   */
+  protected function grantPermission(UserInterface $user, string $permission): void {
+    $regular_roles = $user->getRoles(TRUE);
+
+    $this->assertNotEmpty(
+      $regular_roles,
+      'The user does not have any non-locked roles.'
+    );
+
+    $rid = reset($regular_roles);
+    Role::load($rid)->grantPermission($permission)->save();
+  }
+
+  /**
+   * Revokes the specified permissions from all non-locked roles of a user.
+   *
+   * @param \Drupal\user\UserInterface $user
+   *   The user from which the permission should be revoked.
+   * @param string $permission
+   *   The machine name of the permission to revoke.
+   *
+   * @throws \Drupal\Core\Entity\EntityStorageException
+   *   If any user role fails to save.
+   */
+  protected function revokePermission(UserInterface $user, string $permission): void {
+    $regular_roles = $user->getRoles(TRUE);
+
+    $this->assertNotEmpty(
+      $regular_roles,
+      'The user does not have any non-locked roles.'
+    );
+
+    foreach ($regular_roles as $rid) {
+      Role::load($rid)->revokePermission($permission)->save();
+    }
+  }
+
+}
diff --git a/view_unpublished.install b/view_unpublished.install
index 941e106..d4bca73 100644
--- a/view_unpublished.install
+++ b/view_unpublished.install
@@ -60,3 +60,42 @@ function view_unpublished_update_8002(): void {
   $install_helper = Drupal::service('view_unpublished.install_helper');
   $install_helper->removeDependency();
 }
+
+/**
+ * Switches away from the old "Content Access: View Unpublished" processor.
+ */
+function view_unpublished_update_8003() {
+  // This update function fixes-up any indices that were using an earlier patch
+  // for https://www.drupal.org/project/view_unpublished/issues/2958568. In the
+  // original version of the patch, site builders had to switch to a different
+  // "Content Access" processor in order to use the "View Unpublished" module.
+  // This is no longer necessary -- this module overrides the default one with
+  // a hidden custom version so that site builders can just enable this module
+  // and run.
+  //
+  // Approach adapted from search_api_update_8103().
+  $config_factory = \Drupal::configFactory();
+
+  foreach ($config_factory->listAll('search_api.index.') as $index_id) {
+    $index = $config_factory->getEditable($index_id);
+    $processors = $index->get('processor_settings');
+
+    if (isset($processors['view_unpublished'])) {
+      $processors['content_access'] = $processors['view_unpublished'];
+      unset($processors['view_unpublished']);
+      $index->set('processor_settings', $processors);
+      // Mark the resulting configuration as trusted data. This avoids issues
+      // with future schema changes.
+      $index->save(TRUE);
+    }
+  }
+
+  // Clear the processor plugin cache so that if anything else indirectly tries
+  // to update Search API-related configuration, the plugin helper gets the most
+  // up-to-date plugin definitions.
+  \Drupal::getContainer()
+    ->get('plugin.manager.search_api.processor')
+    ->clearCachedDefinitions();
+
+  return t('Switched from old "Content Access: View Unpublished" to new "Content access" processor with automatic support for "View Unpublished".');
+}
\ No newline at end of file
diff --git a/view_unpublished.module b/view_unpublished.module
index 073f511..61f796f 100644
--- a/view_unpublished.module
+++ b/view_unpublished.module
@@ -12,6 +12,36 @@ use Drupal\Core\Session\AccountInterface;
 use Drupal\node\Entity\NodeType;
 use Drupal\node\NodeInterface;
 
+/**
+ * Implements hook_search_api_processor_info_alter().
+ */
+function view_unpublished_search_api_processor_info_alter(array &$processors) {
+  $content_access_processor = $processors['content_access'] ?? NULL;
+  $view_unpublished_processor = $processors['view_unpublished'] ?? NULL;
+
+  // Automatically replace the default 'content_access' handler with ours so
+  // that this module has immediate effect on searches without site builders
+  // having to reconfigure their search indices. The processor exposed by this
+  // module is hidden so that admins are not confused by two similar options.
+  if (($content_access_processor != NULL) &&
+      ($view_unpublished_processor != NULL)) {
+    $keys_to_swap = [
+      'class',
+      'provider',
+    ];
+
+    $processor_overrides = array_intersect_key(
+      $view_unpublished_processor,
+      array_flip($keys_to_swap)
+    );
+
+    $processors['content_access'] = array_merge(
+      $content_access_processor,
+      $processor_overrides
+    );
+  }
+}
+
 /**
  * Implements hook_node_access_records().
  */
